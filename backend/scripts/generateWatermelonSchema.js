const fs = require('fs');
const path = require('path');

function convertMongooseToWatermelon() {
  // Read the compiled Mongoose models
  const Transaction = require('../dist/models/transaction').default;
  const Category = require('../dist/models/category').default;
  const Account = require('../dist/models/account').default;

  function generateTableSchema(model) {
    const schema = model.schema;
    const tableName = model.collection.name;
    const columns = [];

    schema.eachPath((pathname, schematype) => {
      // Skip internal mongoose fields
      if (pathname === '_id' || pathname === '__v' || pathname === 'id') {
        return;
      }

      // Handle timestamps automatically
      if (pathname === 'createdAt') {
        columns.push({ name: 'created_at', type: 'number' });
        return;
      }
      if (pathname === 'updatedAt') {
        columns.push({ name: 'updated_at', type: 'number' });
        return;
      }

      // Convert camelCase to snake_case
      const columnName = pathname.replace(/[A-Z]/g, letter => `_${letter.toLowerCase()}`);
      
      let columnType = 'string';
      let isOptional = !schematype.isRequired;
      let isIndexed = false;

      // Map Mongoose types to WatermelonDB types
      const instanceType = schematype.instance || schematype.constructor.name;
      
      switch (instanceType) {
        case 'Number':
          columnType = 'number';
          break;
        case 'Boolean':
          columnType = 'boolean';
          break;
        case 'Date':
          columnType = 'number'; // Store as timestamp
          break;
        case 'ObjectID':
          columnType = 'string';
          isIndexed = true; // Most references should be indexed
          break;
        default:
          columnType = 'string';
      }

      // Check if field has an index
      if (schematype._index === true || schema.indexes().some(idx => idx[0][pathname])) {
        isIndexed = true;
      }

      const column = { name: columnName, type: columnType };
      if (isOptional) column.isOptional = true;
      if (isIndexed) column.isIndexed = true;

      columns.push(column);
    });

    return { name: tableName, columns };
  }

  // Generate schemas for all models
  const models = [
    { model: Transaction, name: 'Transaction' },
    { model: Category, name: 'Category' },
    { model: Account, name: 'Account' }
  ];

  const tables = models.map(({ model }) => generateTableSchema(model));

  // Generate the schema file content
  const schemaContent = `import { appSchema, tableSchema } from '@nozbe/watermelondb';

export const schema = appSchema({
  version: 1,
  tables: [
${tables.map(table => `    tableSchema({
      name: '${table.name}',
      columns: [
${table.columns.map(col => {
  const parts = [`name: '${col.name}'`, `type: '${col.type}'`];
  if (col.isOptional) parts.push('isOptional: true');
  if (col.isIndexed) parts.push('isIndexed: true');
  return `        { ${parts.join(', ')} }`;
}).join(',\n')}
      ]
    })`).join(',\n')}
  ]
});

// Auto-generated from Mongoose models on ${new Date().toISOString()}
// Do not edit this file manually - regenerate using: npm run generate:schema`;

  // Create frontend database directory if it doesn't exist
  const frontendDbDir = path.join(__dirname, '../../frontend/src/database');
  if (!fs.existsSync(frontendDbDir)) {
    fs.mkdirSync(frontendDbDir, { recursive: true });
  }

  // Write the schema file
  const outputPath = path.join(frontendDbDir, 'schema.ts');
  fs.writeFileSync(outputPath, schemaContent);

  console.log('‚úÖ WatermelonDB schema generated successfully!');
  console.log(`üìÅ Output: ${outputPath}`);
  console.log('\nüìã Generated tables:');
  tables.forEach(table => {
    console.log(`  ‚Ä¢ ${table.name} (${table.columns.length} columns)`);
  });
}

// Check if compiled models exist
const distPath = path.join(__dirname, '../dist/models');
if (!fs.existsSync(distPath)) {
  console.error('‚ùå Backend models not compiled. Run "tsc" first.');
  process.exit(1);
}

try {
  convertMongooseToWatermelon();
} catch (error) {
  console.error('‚ùå Error generating schema:', error.message);
  process.exit(1);
} 